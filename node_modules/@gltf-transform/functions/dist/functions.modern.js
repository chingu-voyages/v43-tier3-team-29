import{bounds as t,PropertyType as e,BufferUtils as n,Root as s,Primitive as r,Texture as o,ExtensionProperty as i,ImageUtils as a,MathUtils as c,Node as l,AnimationChannel as g,Accessor as u,AnimationSampler as f,uuid as p}from"@gltf-transform/core";export{bounds}from"@gltf-transform/core";import{getPixels as m,savePixels as d}from"ndarray-pixels";import{MeshGPUInstancing as h,MaterialsIOR as A,MaterialsSpecular as y,MaterialsPBRSpecularGlossiness as T,MeshQuantization as E}from"@gltf-transform/extensions";import{invert as S,fromRotationTranslationScale as I,fromScaling as b,multiply as w}from"gl-matrix/mat4";import{transformMat4 as N,min as M,scale as R,max as C}from"gl-matrix/vec3";import O from"ndarray";import{lanczos3 as x,lanczos2 as P}from"ndarray-lanczos";function z(){return(z=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(t[s]=n[s])}return t}).apply(this,arguments)}const L={pivot:"center"};function $(e=L){const n=z({},L,e);return e=>{const s=e.getLogger(),r=e.getRoot(),o=r.listAnimations().length>0||r.listSkins().length>0;e.getRoot().listScenes().forEach((i,a)=>{let c;if(s.debug(`center: Scene ${a+1} / ${r.listScenes().length}.`),"string"==typeof n.pivot){const e=t(i);c=[(e.max[0]-e.min[0])/2+e.min[0],(e.max[1]-e.min[1])/2+e.min[1],(e.max[2]-e.min[2])/2+e.min[2]],"above"===n.pivot&&(c[1]=e.max[1]),"below"===n.pivot&&(c[1]=e.min[1])}else c=n.pivot;s.debug(`center: Pivot "${c.join(", ")}".`);const l=[-1*c[0],-1*c[1],-1*c[2]];if(o){s.debug("center: Model contains animation or skin. Adding a wrapper node.");const t=e.createNode("Pivot").setTranslation(l);i.listChildren().forEach(e=>t.addChild(e)),i.addChild(t)}else s.debug("center: Skipping wrapper, offsetting all root nodes."),i.listChildren().forEach(t=>{const e=t.getTranslation();t.setTranslation([e[0]+l[0],e[1]+l[1],e[2]+l[2]])})}),s.debug("center: Complete.")}}function v(t){return e=>{const n=e.getLogger();if("linear"===t.inputEncoding)return void n.info("colorspace: Vertex colors already linear. Skipping conversion.");if("sRGB"!==t.inputEncoding)return void n.error(`colorspace: Unknown input encoding "${t.inputEncoding}" – should be "sRGB" or "linear". Skipping conversion.`);const s=new Set;function r(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function o(t){const e=[0,0,0];let n;for(let o=0;n=t.getAttribute(`COLOR_${o}`);o++)if(!s.has(n)){for(let t=0;t<n.getCount();t++)n.getElement(t,e),e[0]=r(e[0]),e[1]=r(e[1]),e[2]=r(e[2]),n.setElement(t,e);s.add(n)}}e.getRoot().listMeshes().forEach(t=>t.listPrimitives().forEach(o)),n.debug("colorspace: Complete.")}}const _={propertyTypes:[e.ACCESSOR,e.MESH,e.TEXTURE]},k=function(t=_){const r=z({},_,t),o=new Set(r.propertyTypes);for(const t of r.propertyTypes)if(!_.propertyTypes.includes(t))throw new Error(`dedup: Unsupported deduplication on type "${t}".`);return t=>{const r=t.getLogger();o.has(e.ACCESSOR)&&function(t,e){const s=new Set,r=new Set,o=e.getRoot().listMeshes();function i(t){const e=new Map;for(let s=0;s<t.length;s++){const r=t[s],o=r.getArray().slice().buffer;if(!e.has(r))for(let s=0;s<t.length;s++){const i=t[s];r!==i&&(e.has(i)||r.getType()===i.getType()&&r.getComponentType()===i.getComponentType()&&r.getCount()===i.getCount()&&r.getNormalized()===i.getNormalized()&&n.equals(o,i.getArray().slice().buffer)&&e.set(i,r))}}return e}o.forEach(t=>{t.listPrimitives().forEach(t=>{t.listAttributes().forEach(t=>r.add(t));const e=t.getIndices();e&&s.add(e)})});const a=i(Array.from(s));t.debug(`dedup: Found ${a.size} duplicates among ${s.size} indices.`);const c=i(Array.from(r));t.debug(`dedup: Found ${c.size} duplicates among ${r.size} attributes.`),o.forEach(t=>{t.listPrimitives().forEach(t=>{t.listAttributes().forEach(e=>{c.has(e)&&t.swap(e,c.get(e))});const e=t.getIndices();e&&a.has(e)&&t.swap(e,a.get(e))})}),Array.from(a.keys()).forEach(t=>t.dispose()),Array.from(c.keys()).forEach(t=>t.dispose())}(r,t),o.has(e.MESH)&&function(t,n){const s=n.getRoot(),r=new Map;s.listAccessors().forEach((t,e)=>{r.set(t,e)});const o=s.listMeshes().length,i=new Map;for(const t of s.listMeshes()){const n=[];for(const e of t.listPrimitives()){const t=[];for(const n of e.listSemantics()){const s=e.getAttribute(n);t.push(n+":"+r.get(s))}const s=e.getIndices();s&&t.push("indices:"+r.get(s)),n.push(t.join(","))}const s=n.join(";");if(i.has(s)){const n=i.get(s);t.listParents().forEach(s=>{s.propertyType!==e.ROOT&&s.swap(t,n)}),t.dispose()}else i.set(s,t)}t.debug(`dedup: Found ${o-i.size} duplicates among ${o} meshes.`)}(r,t),o.has(e.TEXTURE)&&function(t,e){const r=e.getRoot(),o=r.listTextures(),i=new Map;for(let t=0;t<o.length;t++){const e=o[t],s=e.getImage();if(!i.has(e))for(let t=0;t<o.length;t++){const r=o[t],a=r.getImage();if(e===r)continue;if(i.has(r))continue;if(e.getMimeType()!==r.getMimeType())continue;const c=e.getSize(),l=r.getSize();c&&l&&c[0]===l[0]&&c[1]===l[1]&&s&&a&&n.equals(s,a)&&i.set(r,e)}}t.debug(`dedup: Found ${i.size} duplicates among ${r.listTextures().length} textures.`),Array.from(i.entries()).forEach(([t,e])=>{t.listParents().forEach(n=>{n instanceof s||n.swap(t,e)}),t.dispose()})}(r,t),r.debug("dedup: Complete.")}};async function F(t,e,n){if(!t)return null;const s=t.getImage();if(!s)return null;const r=await m(new Uint8Array(s),t.getMimeType());for(let t=0;t<r.shape[0];++t)for(let e=0;e<r.shape[1];++e)n(r,t,e);const o=(await d(r,"image/png")).buffer;return e.setImage(o).setMimeType("image/png")}function U(t){const e=t.getIndices(),n=t.getAttribute("POSITION");switch(t.getMode()){case r.Mode.POINTS:return n.getCount();case r.Mode.LINES:return e?e.getCount()/2:n.getCount()/2;case r.Mode.LINE_LOOP:return n.getCount();case r.Mode.LINE_STRIP:return n.getCount()-1;case r.Mode.TRIANGLES:return e?e.getCount()/3:n.getCount()/3;case r.Mode.TRIANGLE_STRIP:case r.Mode.TRIANGLE_FAN:return n.getCount()-2;default:throw new Error("Unexpected mode: "+t.getMode())}}class G{constructor(){this._map=new Map}get size(){return this._map.size}has(t){return this._map.has(t)}add(t,e){let n=this._map.get(t);return n||(n=new Set,this._map.set(t,n)),n.add(e),this}get(t){return this._map.get(t)||new Set}keys(){return this._map.keys()}}function q(t){return{scenes:B(t),meshes:V(t),materials:W(t),textures:D(t),animations:X(t)}}function B(e){return{properties:e.getRoot().listScenes().map(e=>{const n=e.listChildren()[0],s=t(e);return{name:e.getName(),rootName:n?n.getName():"",bboxMin:j(s.min),bboxMax:j(s.max)}})}}function V(t){return{properties:t.getRoot().listMeshes().map(t=>{const e=t.listParents().filter(t=>"Root"!==t.propertyType).length;let n=0,s=0;const r=new Set,o=new Set,i=new Set;t.listPrimitives().forEach(t=>{for(const e of t.listSemantics()){const n=t.getAttribute(e);r.add(e+":"+K(n.getArray())),i.add(n)}for(const e of t.listTargets())e.listAttributes().forEach(t=>i.add(t));const e=t.getIndices();e&&(o.add(K(e.getArray())),i.add(e)),s+=t.listAttributes()[0].getCount(),n+=U(t)});let a=0;Array.from(i).forEach(t=>a+=t.getArray().byteLength);const c=t.listPrimitives().map(t=>H[t.getMode()]);return{name:t.getName(),mode:Array.from(new Set(c)),primitives:t.listPrimitives().length,glPrimitives:n,vertices:s,indices:Array.from(o).sort(),attributes:Array.from(r).sort(),instances:e,size:a}})}}function W(t){return{properties:t.getRoot().listMaterials().map(e=>{const n=e.listParents().filter(t=>"Root"!==t.propertyType).length,s=new Set(e.listExtensions()),r=t.getGraph().getLinks().filter(t=>{const n=t.getChild(),r=t.getParent();return n instanceof o&&r===e||!!(n instanceof o&&r instanceof i&&s.has(r))}).map(t=>t.getName());return{name:e.getName(),instances:n,textures:r,alphaMode:e.getAlphaMode(),doubleSided:e.getDoubleSided()}})}}function D(t){return{properties:t.getRoot().listTextures().map(e=>{const n=e.listParents().filter(t=>"Root"!==t.propertyType).length,s=t.getGraph().listParentLinks(e).map(t=>t.getName()).filter(t=>"texture"!==t),r=a.getSize(e.getImage(),e.getMimeType());return{name:e.getName(),uri:e.getURI(),slots:Array.from(new Set(s)),instances:n,mimeType:e.getMimeType(),resolution:r?r.join("x"):"",size:e.getImage().byteLength,gpuSize:a.getMemSize(e.getImage(),e.getMimeType())}})}}function X(t){return{properties:t.getRoot().listAnimations().map(t=>{let e=Infinity,n=-Infinity;t.listSamplers().forEach(t=>{const s=t.getInput();s&&(e=Math.min(e,s.getMin([])[0]),n=Math.max(n,s.getMax([])[0]))});let s=0,r=0;const o=new Set;return t.listSamplers().forEach(t=>{const e=t.getInput(),n=t.getOutput();e&&(r+=e.getCount(),o.add(e),n&&o.add(n))}),Array.from(o).forEach(t=>{s+=t.getArray().byteLength}),{name:t.getName(),channels:t.listChannels().length,samplers:t.listSamplers().length,duration:Math.round(1e3*(n-e))/1e3,keyframes:r,size:s}})}}const H=["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"];function j(t){for(let e=0;e<t.length;e++)t[e].toFixed&&(t[e]=Number(t[e].toFixed(5)));return t}function K(t){return t.constructor.name.replace("Array","").toLowerCase()}const Z={};function J(t=Z){return z({},Z,t),t=>{const e=t.getLogger(),n=t.getRoot(),s=t.createExtension(h);if(n.listAnimations().length)throw new Error("instance: Instancing is not currently supported for animated models.");let r=0,o=0;for(const i of n.listScenes()){const n=new Map;i.traverse(t=>{const e=t.getMesh();e&&n.set(e,(n.get(e)||new Set).add(t))});const a=[];for(const l of Array.from(n.keys())){const g=Array.from(n.get(l));if(g.length<2)continue;if(g.some(t=>t.getSkin()))continue;const u=Q(t,s,l,g.length),f=u.getAttribute("TRANSLATION"),p=u.getAttribute("ROTATION"),m=u.getAttribute("SCALE"),d=t.createNode().setMesh(l).setExtension("EXT_mesh_gpu_instancing",u);i.addChild(d);let h=!1,A=!1,y=!1;for(let t=0;t<g.length;t++){let e,n,s;const r=g[t];f.setElement(t,e=r.getWorldTranslation()),p.setElement(t,n=r.getWorldRotation()),m.setElement(t,s=r.getWorldScale()),c.eq(e,[0,0,0])||(h=!0),c.eq(n,[0,0,0,1])||(A=!0),c.eq(s,[1,1,1])||(y=!0),r.setMesh(null),a.push(r)}h||f.dispose(),A||p.dispose(),y||m.dispose(),Y(a,e),r++,o+=g.length}}r>0?e.info(`instance: Created ${r} batches, with ${o} total instances.`):(e.info("instance: No meshes with multiple parent nodes were found."),s.dispose()),e.debug("instance: Complete.")}}function Y(t,e){let n,s=0;for(;n=t.pop();){if(n.listChildren().length||n.getCamera()||n.getMesh()||n.getSkin()||n.listExtensions().length)continue;const e=n.getParent();e instanceof l&&t.push(e),n.dispose(),s++}e.debug(`instance: Removed ${s} unused nodes.`)}function Q(t,e,n,s){const r=n.listPrimitives()[0].getAttribute("POSITION").getBuffer(),o=t.createAccessor().setType("VEC3").setArray(new Float32Array(3*s)).setBuffer(r),i=t.createAccessor().setType("VEC4").setArray(new Float32Array(4*s)).setBuffer(r),a=t.createAccessor().setType("VEC3").setArray(new Float32Array(3*s)).setBuffer(r);return e.createInstancedMesh().setAttribute("TRANSLATION",o).setAttribute("ROTATION",i).setAttribute("SCALE",a)}const tt={};function et(t=tt){return z({},tt,t),async t=>{const e=t.getLogger(),n=T.EXTENSION_NAME;if(!t.getRoot().listExtensionsUsed().map(t=>t.extensionName).includes(n))return void e.warn(`metalRough: Extension ${n} not found on given document.`);const s=t.createExtension(A),r=t.createExtension(y),o=t.createExtension(T),i=new Set;for(const e of t.getRoot().listMaterials()){const n=e.getExtension("KHR_materials_pbrSpecularGlossiness");if(!n)continue;const o=r.createSpecular().setSpecularFactor(1).setSpecularColorFactor(n.getSpecularFactor());i.add(n.getSpecularGlossinessTexture()),i.add(e.getBaseColorTexture()),i.add(e.getMetallicRoughnessTexture()),e.setBaseColorFactor(n.getDiffuseFactor()).setMetallicFactor(0).setRoughnessFactor(1).setExtension("KHR_materials_ior",s.createIOR().setIOR(1e3)).setExtension("KHR_materials_specular",o);const a=n.getDiffuseTexture();a&&(e.setBaseColorTexture(a),e.getBaseColorTextureInfo().copy(n.getDiffuseTextureInfo()));const c=n.getSpecularGlossinessTexture();if(c){const s=n.getSpecularGlossinessTextureInfo(),r=t.createTexture();await F(c,r,(t,e,n)=>{t.set(e,n,3,255)}),o.setSpecularTexture(r),o.setSpecularColorTexture(r),o.getSpecularTextureInfo().copy(s),o.getSpecularColorTextureInfo().copy(s);const i=n.getGlossinessFactor(),a=t.createTexture();await F(c,a,(t,e,n)=>{const s=255-Math.round(t.get(e,n,3)*i);t.set(e,n,0,0),t.set(e,n,1,s),t.set(e,n,2,0),t.set(e,n,3,255)}),e.setMetallicRoughnessTexture(a),e.getMetallicRoughnessTextureInfo().copy(s)}else o.setSpecularColorFactor(n.getSpecularFactor()),e.setRoughnessFactor(1-n.getGlossinessFactor());e.setExtension("KHR_materials_pbrSpecularGlossiness",null)}o.dispose();for(const t of i)t&&1===t.listParents().length&&t.dispose();e.debug("metalRough: Complete.")}}const nt={propertyTypes:[e.NODE,e.SKIN,e.MESH,e.CAMERA,e.PRIMITIVE,e.PRIMITIVE_TARGET,e.ANIMATION,e.MATERIAL,e.TEXTURE,e.ACCESSOR,e.BUFFER]},st=function(t=nt){const n=z({},nt,t).propertyTypes;return t=>{const r=t.getLogger(),o=t.getRoot(),i=t.getGraph(),a={};if(n.includes(e.NODE)&&o.listNodes().forEach(c),n.includes(e.SKIN)&&o.listSkins().forEach(c),n.includes(e.MESH)&&o.listMeshes().forEach(c),n.includes(e.CAMERA)&&o.listCameras().forEach(c),n.includes(e.PRIMITIVE)&&l(i,e.PRIMITIVE),n.includes(e.PRIMITIVE_TARGET)&&l(i,e.PRIMITIVE_TARGET),n.includes(e.ANIMATION))for(const t of o.listAnimations()){for(const e of t.listChannels())e.getTargetNode()||(e.dispose(),u(e));if(t.listChannels().length)t.listSamplers().forEach(c);else{const e=t.listSamplers();c(t),e.forEach(c)}}if(n.includes(e.MATERIAL)&&o.listMaterials().forEach(c),n.includes(e.TEXTURE)&&o.listTextures().forEach(c),n.includes(e.ACCESSOR)&&o.listAccessors().forEach(c),n.includes(e.BUFFER)&&o.listBuffers().forEach(c),Object.keys(a).length){const t=Object.keys(a).map(t=>`${t} (${a[t]})`).join(", ");r.info(`prune: Removed types... ${t}`)}else r.info("prune: No unused properties found.");function c(t){t.listParents().filter(t=>!(t instanceof s||t instanceof g)).length||(t.dispose(),u(t))}function l(t,e){t.getLinks().map(t=>t.getParent()).filter(t=>t.propertyType===e).forEach(c)}function u(t){a[t.propertyType]=a[t.propertyType]||0,a[t.propertyType]++}r.debug("prune: Complete.")}},rt={animations:!0,meshes:!0},ot=(t=rt)=>{const n=z({},rt,t);return async t=>{const s=t.getLogger();!1!==n.meshes&&function(t,e,n){const s=new Set(t.getRoot().listBuffers().map(t=>t.getURI()));t.getRoot().listMeshes().forEach((r,o)=>{if(Array.isArray(n.meshes)&&!n.meshes.includes(r.getName()))return void e.debug(`partition: Skipping mesh #${o} with name "${r.getName()}".`);e.debug(`partition: Creating buffer for mesh "${r.getName()}".`);const i=t.createBuffer(r.getName()).setURI(it(r.getName()||"mesh",s));r.listPrimitives().forEach(t=>{const e=t.getIndices();e&&e.setBuffer(i),t.listAttributes().forEach(t=>t.setBuffer(i)),t.listTargets().forEach(t=>{t.listAttributes().forEach(t=>t.setBuffer(i))})})})}(t,s,n),!1!==n.animations&&function(t,e,n){const s=new Set(t.getRoot().listBuffers().map(t=>t.getURI()));t.getRoot().listAnimations().forEach((r,o)=>{if(Array.isArray(n.animations)&&!n.animations.includes(r.getName()))return void e.debug(`partition: Skipping animation #${o} with name "${r.getName()}".`);e.debug(`partition: Creating buffer for animation "${r.getName()}".`);const i=t.createBuffer(r.getName()).setURI(it(r.getName()||"animation",s));r.listSamplers().forEach(t=>{const e=t.getInput(),n=t.getOutput();e&&e.setBuffer(i),n&&n.setBuffer(i)})})}(t,s,n),n.meshes||n.animations||s.warn("partition: Select animations or meshes to create a partition."),await t.transform(st({propertyTypes:[e.BUFFER]})),s.debug("partition: Complete.")}};function it(t,e){let n=`${t}.bin`,s=1;for(;e.has(n);)n=`${t}_${s++}.bin`;return n}const at=[Int8Array,Int16Array,Int32Array],{TRANSLATION:ct,ROTATION:lt,SCALE:gt,WEIGHTS:ut}=g.TargetPath,ft=[ct,lt,gt],pt={pattern:/.*/,quantizationVolume:"mesh",quantizePosition:14,quantizeNormal:10,quantizeTexcoord:12,quantizeColor:8,quantizeWeight:8,quantizeGeneric:12},mt=(t=pt)=>{const n=z({},pt,t);return async t=>{const s=t.getLogger(),r=t.getRoot();let o;t.createExtension(E).setRequired(!0),"scene"===n.quantizationVolume&&(o=ht(function(t){const e=t[0];for(const n of t)M(e.min,e.min,n.min),C(e.max,e.max,n.max);return e}(r.listMeshes().map(St))));for(const e of t.getRoot().listMeshes()){"mesh"===n.quantizationVolume&&(o=ht(St(e))),o&&n.pattern.test("POSITION")&&At(t,e,o);for(const s of e.listPrimitives()){dt(t,s,o,n);for(const e of s.listTargets())dt(t,e,o,n)}}await t.transform(st({propertyTypes:[e.ACCESSOR,e.SKIN]}),k({propertyTypes:[e.ACCESSOR]})),s.debug("quantize: Complete.")}};function dt(t,e,n,s){const o=t.getLogger();for(const t of e.listSemantics()){if(!s.pattern.test(t))continue;const i=e.getAttribute(t),{bits:a,ctor:c}=Et(t,i,o,s);if(!c)continue;if(a<8||a>16)throw new Error("quantize: Requires bits = 8–16.");if(i.getComponentSize()<=a/8)continue;const l=i.clone();if("POSITION"===t){const t=n.scale,s=[];e instanceof r?S(s,bt(n)):b(s,[1/t,1/t,1/t]);for(let t=0,e=[0,0,0],n=l.getCount();t<n;t++)l.getElement(t,e),l.setElement(t,N(e,e,s))}Tt(l,c,a),e.swap(i,l)}if(e.getAttribute("WEIGHTS_0")&&function(t){const e=t.getAttribute("POSITION").getCount(),n=[];for(let s=0;s<e;s++){let e,r=0,o=Infinity,i=-1,a=null,c=0;for(;e=t.getAttribute("WEIGHTS_"+c++);){e.getElement(s,n);for(let t=0;t<n.length;t++)r+=n[t],n[t]>0&&n[t]<o&&(a=e,o=n[t],i=t)}a&&1!==r&&(a.getElement(s,n),n[i]+=1-r,a.setElement(s,n))}}(e),e instanceof r&&e.getIndices()&&e.listAttributes().length&&e.listAttributes()[0].getCount()<65535){const t=e.getIndices();t.setArray(new Uint16Array(t.getArray()))}}function ht(t){const{min:e,max:n}=t,s=Math.max((n[0]-e[0])/2,(n[1]-e[1])/2,(n[2]-e[2])/2);return{offset:[e[0]+(n[0]-e[0])/2,e[1]+(n[1]-e[1])/2,e[2]+(n[2]-e[2])/2],scale:s}}function At(t,e,n){const s=bt(n);for(const r of e.listParents())if(r instanceof l){const o=r.listParents().filter(t=>t instanceof g),i=o.some(t=>ft.includes(t.getTargetPath())),a=r.listChildren().length>0;if(r.getSkin()){r.setSkin(yt(r.getSkin(),n));continue}let c;a||i?(c=t.createNode("").setMesh(e),r.addChild(c).setMesh(null),o.filter(t=>t.getTargetPath()===ut).forEach(t=>t.setTargetNode(c))):c=r;const l=c.getMatrix();w(l,l,s),c.setMatrix(l)}}function yt(t,e){t=t.clone();const n=bt(e),s=t.getInverseBindMatrices().clone(),r=[];for(let t=0,e=s.getCount();t<e;t++)s.getElement(t,r),w(r,r,n),s.setElement(t,r);return t.setInverseBindMatrices(s)}function Tt(t,e,n){const s=new e(t.getArray().length),r=at.includes(e)?1:0,o=n-r,i=8*e.BYTES_PER_ELEMENT-r,a=Math.pow(2,o)-1,c=i-o,l=2*o-i;for(let e=0,n=0,r=[];e<t.getCount();e++){t.getElement(e,r);for(let t=0;t<r.length;t++){let e=Math.round(Math.abs(r[t])*a);e=e<<c|e>>l,s[n++]=e*Math.sign(r[t])}}t.setArray(s).setNormalized(!0)}function Et(t,e,n,s){const r=e.getMinNormalized([]),o=e.getMaxNormalized([]);let i,a;if("POSITION"===t)i=s.quantizePosition,a=i<=8?Int8Array:Int16Array;else if("NORMAL"===t||"TANGENT"===t)i=s.quantizeNormal,a=i<=8?Int8Array:Int16Array;else if(t.startsWith("COLOR_"))i=s.quantizeColor,a=i<=8?Uint8Array:Uint16Array;else if(t.startsWith("TEXCOORD_")){if(r.some(t=>t<0)||o.some(t=>t>1))return n.warn(`quantize: Skipping ${t}; out of [0,1] range.`),{bits:-1};i=s.quantizeTexcoord,a=i<=8?Uint8Array:Uint16Array}else{if(t.startsWith("JOINTS_"))return i=Math.max(...e.getMax([]))<=255?8:16,a=i<=8?Uint8Array:Uint16Array,e.getComponentSize()>i/8&&e.setArray(new a(e.getArray())),{bits:-1};if(t.startsWith("WEIGHTS_")){if(r.some(t=>t<0)||o.some(t=>t>1))return n.warn(`quantize: Skipping ${t}; out of [0,1] range.`),{bits:-1};i=s.quantizeWeight,a=i<=8?Uint8Array:Uint16Array}else{if(!t.startsWith("_"))throw new Error(`quantize: Unexpected semantic, "${t}".`);if(r.some(t=>t<-1)||o.some(t=>t>1))return n.warn(`quantize: Skipping ${t}; out of [-1,1] range.`),{bits:-1};i=s.quantizeGeneric,a=a=r.some(t=>t<0)?i<=8?Int8Array:Int16Array:i<=8?Uint8Array:Uint16Array}}return{bits:i,ctor:a}}function St(t){const e=[],n=[];for(const s of t.listPrimitives()){const t=s.getAttribute("POSITION");t&&e.push(t);for(const t of s.listTargets()){const e=t.getAttribute("POSITION");e&&n.push(e)}}if(0===e.length)throw new Error('quantize: Missing "POSITION" attribute.');const s=It(e,3);if(n.length>0){const{min:t,max:e}=It(n,3);M(s.min,s.min,M(t,R(t,t,2),[0,0,0])),C(s.max,s.max,C(e,R(e,e,2),[0,0,0]))}return s}function It(t,e){const n=new Array(e).fill(Infinity),s=new Array(e).fill(-Infinity),r=[],o=[];for(const i of t){i.getMinNormalized(r),i.getMaxNormalized(o);for(let t=0;t<e;t++)n[t]=Math.min(n[t],r[t]),s[t]=Math.max(s[t],o[t])}return{min:n,max:s}}function bt(t){return I([],[0,0,0,1],t.offset,[t.scale,t.scale,t.scale])}const wt={tolerance:1e-4},Nt=(t=wt)=>{const e=z({},wt,t);return t=>{const n=new Set,r=t.getRoot().listAccessors().length,o=t.getLogger();let i=!1;for(const s of t.getRoot().listAnimations()){const t=new Set;for(const e of s.listChannels())e.getSampler()&&"weights"===e.getTargetPath()&&t.add(e.getSampler());for(const r of s.listSamplers())t.has(r)?i=!0:"STEP"!==r.getInterpolation()&&"LINEAR"!==r.getInterpolation()||(n.add(r.getInput()),n.add(r.getOutput()),Mt(r,e))}for(const t of Array.from(n.values()))t.listParents().some(t=>!(t instanceof s))||t.dispose();t.getRoot().listAccessors().length>r&&o.warn('resample: Resampling required copying accessors, some of which may be duplicates. Consider using "dedup" to consolidate any duplicates.'),i&&o.warn("resample: Skipped optimizing morph target keyframes, not yet supported."),o.debug("resample: Complete.")}};function Mt(t,e){const n=t.getInput().clone(),s=t.getOutput().clone(),r=e.tolerance,o=n.getCount()-1,i=[];let a=1;for(let e=1;e<o;++e){const o=n.getScalar(e),l=n.getScalar(e-1),g=n.getScalar(e+1),u=(o-l)/(g-l);let f=!1;if(o!==g&&(1!==e||o!==n.getScalar(0)))for(let n=0;n<s.getElementSize();n++){const o=s.getElement(e,i)[n],a=s.getElement(e-1,i)[n],l=s.getElement(e+1,i)[n];if("LINEAR"===t.getInterpolation()){if(Math.abs(o-(a*(1-(c=u))+l*c))>r){f=!0;break}}else if("STEP"===t.getInterpolation()&&(o!==a||o!==l)){f=!0;break}}f&&(e!==a&&(n.setScalar(a,n.getScalar(e)),s.setElement(a,s.getElement(e,i))),a++)}var c;o>0&&(n.setScalar(a,n.getScalar(o)),s.setElement(a,s.getElement(o,i)),a++),a!==n.getCount()?(n.setArray(n.getArray().slice(0,a)),s.setArray(s.getArray().slice(0,a*s.getElementSize())),t.setInput(n),t.setOutput(s)):(n.dispose(),s.dispose())}const Rt={target:"size"};function Ct(t=Rt){const n=z({},Rt,t),s=n.encoder;return async t=>{const o=t.getLogger();await s.ready;const i=function(t){const e=new G,n=new Map,s=new G;for(const r of t.getRoot().listMeshes())for(const t of r.listPrimitives()){const r=t.getIndices();if(r){n.set(r,t.getMode());for(const n of xt(t))e.add(r,n),s.add(n,t)}}return{indicesToAttributes:e,indicesToMode:n,attributesToPrimitives:s}}(t);for(const t of i.indicesToAttributes.keys()){const e=t.clone();let o=e.getArray().slice();o instanceof Uint32Array||(o=new Uint32Array(o));const[a,c]=s.reorderMesh(o,i.indicesToMode.get(t)===r.Mode.TRIANGLES,"size"===n.target);e.setArray(c<=65534?new Uint16Array(o):o);for(const n of i.indicesToAttributes.get(t)){const s=n.clone();Ot(s,a,c);for(const r of i.attributesToPrimitives.get(n))if(r.getIndices()===t&&r.swap(t,e),r.getIndices()===e){r.swap(n,s);for(const t of r.listTargets())t.swap(n,s)}}}await t.transform(st({propertyTypes:[e.ACCESSOR]})),i.indicesToAttributes.size?o.debug("reorder: Complete."):o.warn("reorder: No qualifying primitives found; may need to weld first.")}}function Ot(t,e,n){const s=t.getElementSize(),r=t.getCount(),o=t.getArray(),i=o.slice(0,n*s);for(let t=0;t<r;t++)for(let n=0;n<s;n++)i[e[t]*s+n]=o[t*s+n];t.setArray(i)}function xt(t){const e=[];for(const n of t.listAttributes())e.push(n);for(const n of t.listTargets())for(const t of n.listAttributes())e.push(t);return Array.from(new Set(e))}const Pt={name:"",fps:10,pattern:/.*/,sort:!0};function zt(t=Pt){const e=z({},Pt,t);return t=>{const n=t.getLogger(),s=t.getRoot(),r=e.fps,o=s.listNodes().filter(t=>t.getName().match(e.pattern));e.sort&&o.sort((t,e)=>t.getName()>e.getName()?1:-1);const i=t.createAnimation(e.name),a=s.listBuffers()[0];o.forEach((e,n)=>{let s,c;0===n?(s=[n/r,(n+1)/r],c=[1,1,1,0,0,0]):n===o.length-1?(s=[(n-1)/r,n/r],c=[0,0,0,1,1,1]):(s=[(n-1)/r,n/r,(n+1)/r],c=[0,0,0,1,1,1,0,0,0]);const l=t.createAccessor().setArray(new Float32Array(s)).setBuffer(a),p=t.createAccessor().setArray(new Float32Array(c)).setBuffer(a).setType(u.Type.VEC3),m=t.createAnimationSampler().setInterpolation(f.Interpolation.STEP).setInput(l).setOutput(p),d=t.createAnimationChannel().setTargetNode(e).setTargetPath(g.TargetPath.SCALE).setSampler(m);i.addSampler(m).addChannel(d)}),n.debug("sequence: Complete.")}}const Lt={overwrite:!1};function $t(t=Lt){if(!t.generateTangents)throw new Error('tangents: generateTangents callback required — install "mikktspace".');const e=z({},Lt,t);return t=>{const n=t.getLogger(),s=new Map,r=new Map;let o=0;for(const i of t.getRoot().listMeshes()){const a=i.getName(),c=i.listPrimitives();for(let i=0;i<c.length;i++){const l=c[i];if(!_t(l,n,a,i,e.overwrite))continue;const g=vt(l),u=l.getAttribute("POSITION").getArray(),f=l.getAttribute("NORMAL").getArray(),m=l.getAttribute(g).getArray(),d=s.get(u)||p();s.set(u,d);const h=s.get(f)||p();s.set(f,h);const A=s.get(m)||p();s.set(m,A);const y=l.getAttribute("TANGENT");y&&2===y.listParents().length&&y.dispose();const T=`${d}|${h}|${A}`;let E=r.get(T);if(E){n.debug(`tangents: Found cache for primitive ${i} of mesh "${a}".`),l.setAttribute("TANGENT",E),o++;continue}n.debug(`tangents: Generating for primitive ${i} of mesh "${a}".`);const S=l.getAttribute("POSITION").getBuffer(),I=e.generateTangents(u instanceof Float32Array?u:new Float32Array(u),f instanceof Float32Array?f:new Float32Array(f),m instanceof Float32Array?m:new Float32Array(m));for(let t=3;t<I.length;t+=4)I[t]*=-1;E=t.createAccessor().setBuffer(S).setArray(I).setType("VEC4"),l.setAttribute("TANGENT",E),r.set(T,E),o++}}o?n.debug("tangents: Complete."):n.warn("tangents: No qualifying primitives found. See debug output.")}}function vt(t){const e=t.getMaterial();if(!e)return"TEXCOORD_0";const n=e.getNormalTextureInfo();if(!n)return"TEXCOORD_0";const s=`TEXCOORD_${n.getTexCoord()}`;return t.getAttribute(s)?s:"TEXCOORD_0"}function _t(t,e,n,s,o){return t.getMode()===r.Mode.TRIANGLES&&t.getAttribute("POSITION")&&t.getAttribute("NORMAL")&&t.getAttribute("TEXCOORD_0")?t.getAttribute("TANGENT")&&!o?(e.debug(`tangents: Skipping primitive ${s} of mesh "${n}": TANGENT found.`),!1):!t.getIndices()||(e.warn(`tangents: Skipping primitive ${s} of mesh "${n}": primitives must be unwelded.`),!1):(e.debug(`tangents: Skipping primitive ${s} of mesh "${n}": primitives must have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.`),!1)}const kt="textureResize";var Ft;!function(t){t.LANCZOS3="lanczos3",t.LANCZOS2="lanczos2"}(Ft||(Ft={}));const Ut={size:[2048,2048],filter:Ft.LANCZOS3,pattern:null};function Gt(t=Ut){const e=z({},Ut,t);return async t=>{const n=t.getLogger();for(const s of t.getRoot().listTextures()){const t=s.getName(),r=s.getURI();if(e.pattern&&!e.pattern.test(t)&&!e.pattern.test(r))continue;if("image/png"!==s.getMimeType()&&"image/jpeg"!==s.getMimeType()){n.warn(`Skipping unsupported texture type, "${s.getMimeType()}".`);continue}const[o,i]=e.size,[a,c]=s.getSize();if(a<=o&&c<=i){n.debug(`${kt}: Skipping "${r||t}", within size range.`);continue}let l=a,g=c;l>o&&(g=Math.floor(g*(o/l)),l=o),g>i&&(l=Math.floor(l*(i/g)),g=i);const u=new Uint8Array(s.getImage()),f=await m(u,s.getMimeType()),p=O(new Uint8Array(l*g*4),[l,g,4]);n.debug(`${kt}: Resizing "${r||t}", ${f.shape} → ${p.shape}...`);try{e.filter===Ft.LANCZOS3?x(f,p):P(f,p)}catch(e){if(e instanceof Error){n.warn(`${kt}: Failed to resize "${r||t}": "${e.message}".`);continue}throw e}s.setImage((await d(p,s.getMimeType())).buffer)}n.debug(`${kt}: Complete.`)}}const qt={};function Bt(t=qt){return z({},qt,t),t=>{const e=t.getLogger(),n=new Map;for(const s of t.getRoot().listMeshes())for(const t of s.listPrimitives()){const s=t.getIndices();if(s){for(const r of t.listAttributes())t.swap(r,Vt(r,s,e,n)),1===r.listParents().length&&r.dispose();for(const r of t.listTargets())for(const t of r.listAttributes())r.swap(t,Vt(t,s,e,n)),1===t.listParents().length&&t.dispose();t.setIndices(null),1===s.listParents().length&&s.dispose()}}e.debug("unweld: Complete.")}}function Vt(t,e,n,s){if(s.has(t)&&s.get(t).has(e))return n.debug(`unweld: Cache hit for reused attribute, "${t.getName()}".`),s.get(t).get(e);const r=t.clone(),o=t.getArray().constructor;r.setArray(new o(e.getCount()*t.getElementSize()));const i=[];for(let n=0;n<e.getCount();n++)r.setElement(n,t.getElement(e.getScalar(n),i));return s.has(t)||s.set(t,new Map),s.get(t).set(e,r),r}const Wt={tolerance:1e-4};function Dt(t=Wt){const e=z({},Wt,t);return t=>{const n=t.getLogger();for(const n of t.getRoot().listMeshes())for(const s of n.listPrimitives())0===e.tolerance?Xt(t,s):Ht(t,s,e);n.debug("weld: Complete.")}}function Xt(t,e){if(e.getIndices())return;const n=e.listAttributes()[0],s=n.getCount(),r=n.getBuffer(),o=s<=65534?new Uint16Array(3*U(e)):new Uint32Array(3*U(e)),i=t.createAccessor().setBuffer(r).setType(u.Type.SCALAR).setArray(o);for(let t=0;t<i.getCount();t++)i.setScalar(t,t);e.setIndices(i)}function Ht(t,e,n){const s=Math.max(n.tolerance,Number.EPSILON),r=Math.log10(1/s),o=Math.pow(10,r),i={},a=e.getIndices(),c=a?a.getCount():e.listAttributes()[0].getCount(),l=new Map;e.listAttributes().forEach(t=>l.set(t,[])),e.listTargets().forEach(t=>{t.listAttributes().forEach(t=>l.set(t,[]))});const g=[];let u=0;for(let t=0;t<c;t++){const n=a?a.getScalar(t):t,s=[],r=[];for(const t of e.listAttributes())for(let e=0;e<t.getElementSize();e++)s.push(~~(t.getElement(n,r)[e]*o));const c=s.join("|");if(c in i)g.push(i[c]);else{for(const t of e.listAttributes())l.get(t).push(t.getElement(n,[]));for(const t of e.listTargets())for(const e of t.listAttributes())l.get(e).push(e.getElement(n,[]));i[c]=u,g.push(u),u++}}const f=e.listAttributes()[0].getCount(),p=l.get(e.getAttribute("POSITION")).length;t.getLogger().debug(`weld: ${f} → ${p} vertices.`);for(const t of e.listAttributes())Kt(e,t,l.get(t)),1===t.listParents().length&&t.dispose();for(const t of e.listTargets())for(const e of t.listAttributes())Kt(t,e,l.get(e)),1===e.listParents().length&&e.dispose();if(a){const t=jt(a.getArray(),g.length);t.set(g),e.setIndices(a.clone().setArray(t)),1===a.listParents().length&&a.dispose()}else{const n=f<=65534?new Uint16Array(g):new Uint32Array(g);e.setIndices(t.createAccessor().setArray(n))}}function jt(t,e){return new(0,t.constructor)(e)}function Kt(t,e,n){const s=n.length*e.getElementSize(),r=jt(e.getArray(),s),o=e.clone().setArray(r);for(let t=0;t<n.length;t++)o.setElement(t,n[t]);t.swap(e,o)}export{pt as QUANTIZE_DEFAULTS,Ut as TEXTURE_RESIZE_DEFAULTS,Ft as TextureResizeFilter,$ as center,v as colorspace,k as dedup,q as inspect,J as instance,et as metalRough,ot as partition,st as prune,mt as quantize,Ct as reorder,Nt as resample,zt as sequence,$t as tangents,Gt as textureResize,Bt as unweld,Dt as weld};
//# sourceMappingURL=functions.modern.js.map
