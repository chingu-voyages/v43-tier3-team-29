"use strict";var qt=Object.create;var ze=Object.defineProperty;var Qt=Object.getOwnPropertyDescriptor;var zt=Object.getOwnPropertyNames;var Gt=Object.getPrototypeOf,Bt=Object.prototype.hasOwnProperty;var Kt=(t,e)=>{for(var n in e)ze(t,n,{get:e[n],enumerable:!0})},Qe=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of zt(e))!Bt.call(t,o)&&o!==n&&ze(t,o,{get:()=>e[o],enumerable:!(r=Qt(e,o))||r.enumerable});return t},L=(t,e,n)=>(Qe(t,e,"default"),n&&Qe(n,e,"default")),Pt=(t,e,n)=>(n=t!=null?qt(Gt(t)):{},Qe(e||!t||!t.__esModule?ze(n,"default",{value:t,enumerable:!0}):n,t)),Xt=t=>Qe(ze({},"__esModule",{value:!0}),t);var U={};Kt(U,{BailSignal:()=>Ce,Controller:()=>pe,FrameValue:()=>te,Globals:()=>Ae.Globals,Interpolation:()=>se,Spring:()=>mn,SpringContext:()=>re,SpringRef:()=>le,SpringValue:()=>ue,Trail:()=>hn,Transition:()=>gn,config:()=>it,createInterpolator:()=>fe.createInterpolator,easings:()=>fe.easings,inferTo:()=>Se,interpolate:()=>Pn,to:()=>Sn,update:()=>Tn,useChain:()=>$t,useInView:()=>dn,useIsomorphicLayoutEffect:()=>fe.useIsomorphicLayoutEffect,useReducedMotion:()=>fe.useReducedMotion,useResize:()=>cn,useScroll:()=>ln,useSpring:()=>oe,useSpringRef:()=>sn,useSpringValue:()=>an,useSprings:()=>je,useTrail:()=>ht,useTransition:()=>gt});module.exports=Xt(U);var Z=require("@react-spring/shared");var V=require("@react-spring/shared");function k(t,...e){return V.is.fun(t)?t(...e):t}var ge=(t,e)=>t===!0||!!(e&&t&&(V.is.fun(t)?t(e):(0,V.toArray)(t).includes(e))),st=(t,e)=>V.is.obj(t)?e&&t[e]:t;var Ge=(t,e)=>t.default===!0?t[e]:t.default?t.default[e]:void 0,Yt=t=>t,ye=(t,e=Yt)=>{let n=Ht;t.default&&t.default!==!0&&(t=t.default,n=Object.keys(t));let r={};for(let o of n){let s=e(t[o],o);V.is.und(s)||(r[o]=s)}return r},Ht=["config","onProps","onStart","onChange","onPause","onResume","onRest"],Jt={config:1,from:1,to:1,ref:1,loop:1,reset:1,pause:1,cancel:1,reverse:1,immediate:1,default:1,delay:1,onProps:1,onStart:1,onChange:1,onPause:1,onResume:1,onRest:1,onResolve:1,items:1,trail:1,sort:1,expires:1,initial:1,enter:1,update:1,leave:1,children:1,onDestroyed:1,keys:1,callId:1,parentId:1};function Wt(t){let e={},n=0;if((0,V.eachProp)(t,(r,o)=>{Jt[o]||(e[o]=r,n++)}),n)return e}function Se(t){let e=Wt(t);if(e){let n={to:e};return(0,V.eachProp)(t,(r,o)=>o in e||(n[o]=r)),n}return{...t}}function Re(t){return t=(0,V.getFluidValue)(t),V.is.arr(t)?t.map(Re):(0,V.isAnimatedString)(t)?V.Globals.createStringInterpolator({range:[0,1],output:[t,t]})(1):t}function Be(t){for(let e in t)return!0;return!1}function Ke(t){return V.is.fun(t)||V.is.arr(t)&&V.is.obj(t[0])}function ke(t,e){t.ref?.delete(t),e?.delete(t)}function ve(t,e){e&&t.ref!==e&&(t.ref?.delete(t),e.add(t),t.ref=e)}function $t(t,e,n=1e3){(0,Z.useIsomorphicLayoutEffect)(()=>{if(e){let r=0;(0,Z.each)(t,(o,s)=>{let u=o.current;if(u.length){let a=n*e[s];isNaN(a)?a=r:r=a,(0,Z.each)(u,p=>{(0,Z.each)(p.queue,l=>{let d=l.delay;l.delay=m=>a+k(d||0,m)})}),o.start()}})}else{let r=Promise.resolve();(0,Z.each)(t,o=>{let s=o.current;if(s.length){let u=s.map(a=>{let p=a.queue;return a.queue=[],p});r=r.then(()=>((0,Z.each)(s,(a,p)=>(0,Z.each)(u[p]||[],l=>a.queue.push(l))),Promise.all(o.start())))}})}})}var Et=require("@react-spring/shared");var J=require("react"),j=require("@react-spring/shared");var i=require("@react-spring/shared"),_=require("@react-spring/animated");var H=require("@react-spring/shared");var it={default:{tension:170,friction:26},gentle:{tension:120,friction:14},wobbly:{tension:180,friction:12},stiff:{tension:210,friction:20},slow:{tension:280,friction:60},molasses:{tension:280,friction:120}};var at={...it.default,mass:1,damping:1,easing:H.easings.linear,clamp:!1},Xe=class{tension;friction;frequency;damping;mass;velocity=0;restVelocity;precision;progress;duration;easing;clamp;bounce;decay;round;constructor(){Object.assign(this,at)}};function xt(t,e,n){n&&(n={...n},Tt(n,e),e={...n,...e}),Tt(t,e),Object.assign(t,e);for(let u in at)t[u]==null&&(t[u]=at[u]);let{mass:r,frequency:o,damping:s}=t;return H.is.und(o)||(o<.01&&(o=.01),s<0&&(s=0),t.tension=Math.pow(2*Math.PI/o,2)*r,t.friction=4*Math.PI*s*r/o),t}function Tt(t,e){if(!H.is.und(e.decay))t.duration=void 0;else{let n=!H.is.und(e.tension)||!H.is.und(e.friction);(n||!H.is.und(e.frequency)||!H.is.und(e.damping)||!H.is.und(e.mass))&&(t.duration=void 0,t.decay=void 0),n&&(t.frequency=void 0)}}var bt=[],Ye=class{changed=!1;values=bt;toValues=null;fromValues=bt;to;from;config=new Xe;immediate=!1};var Pe=require("@react-spring/shared");function He(t,{key:e,props:n,defaultProps:r,state:o,actions:s}){return new Promise((u,a)=>{let p,l,d=ge(n.cancel??r?.cancel,e);if(d)v();else{Pe.is.und(n.pause)||(o.paused=ge(n.pause,e));let f=r?.pause;f!==!0&&(f=o.paused||ge(f,e)),p=k(n.delay||0,e),f?(o.resumeQueue.add(h),s.pause()):(s.resume(),h())}function m(){o.resumeQueue.add(h),o.timeouts.delete(l),l.cancel(),p=l.time-Pe.raf.now()}function h(){p>0&&!Pe.Globals.skipAnimation?(o.delayed=!0,l=Pe.raf.setTimeout(v,p),o.pauseQueue.add(m),o.timeouts.add(l)):v()}function v(){o.delayed&&(o.delayed=!1),o.pauseQueue.delete(m),o.timeouts.delete(l),t<=(o.cancelId||0)&&(d=!0);try{s.start({...n,callId:t,cancel:d},u)}catch(f){a(f)}}})}var Q=require("@react-spring/shared");var Ue=(t,e)=>e.length==1?e[0]:e.some(n=>n.cancelled)?ee(t.get()):e.every(n=>n.noop)?ut(t.get()):G(t.get(),e.every(n=>n.finished)),ut=t=>({value:t,noop:!0,finished:!0,cancelled:!1}),G=(t,e,n=!1)=>({value:t,finished:e,cancelled:n}),ee=t=>({value:t,cancelled:!0,finished:!1});function We(t,e,n,r){let{callId:o,parentId:s,onRest:u}=e,{asyncTo:a,promise:p}=n;return!s&&t===a&&!e.reset?p:n.promise=(async()=>{n.asyncId=o,n.asyncTo=t;let l=ye(e,(c,g)=>g==="onRest"?void 0:c),d,m,h=new Promise((c,g)=>(d=c,m=g)),v=c=>{let g=o<=(n.cancelId||0)&&ee(r)||o!==n.asyncId&&G(r,!1);if(g)throw c.result=g,m(c),c},f=(c,g)=>{let y=new Ce,A=new Je;return(async()=>{if(Q.Globals.skipAnimation)throw Te(n),A.result=G(r,!1),m(A),A;v(y);let P=Q.is.obj(c)?{...c}:{...g,to:c};P.parentId=o,(0,Q.eachProp)(l,(E,w)=>{Q.is.und(P[w])&&(P[w]=E)});let I=await r.start(P);return v(y),n.paused&&await new Promise(E=>{n.resumeQueue.add(E)}),I})()},T;if(Q.Globals.skipAnimation)return Te(n),G(r,!1);try{let c;Q.is.arr(t)?c=(async g=>{for(let y of g)await f(y)})(t):c=Promise.resolve(t(f,r.stop.bind(r))),await Promise.all([c.then(d),h]),T=G(r.get(),!0,!1)}catch(c){if(c instanceof Ce)T=c.result;else if(c instanceof Je)T=c.result;else throw c}finally{o==n.asyncId&&(n.asyncId=s,n.asyncTo=s?a:void 0,n.promise=s?p:void 0)}return Q.is.fun(u)&&Q.raf.batchedUpdates(()=>{u(T,r,r.item)}),T})()}function Te(t,e){(0,Q.flush)(t.timeouts,n=>n.cancel()),t.pauseQueue.clear(),t.resumeQueue.clear(),t.asyncId=t.asyncTo=t.promise=void 0,e&&(t.cancelId=e)}var Ce=class extends Error{result;constructor(){super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.")}},Je=class extends Error{result;constructor(){super("SkipAnimationSignal")}};var X=require("@react-spring/shared"),At=require("@react-spring/animated"),Ee=t=>t instanceof te,Zt=1,te=class extends X.FluidValue{id=Zt++;_priority=0;get priority(){return this._priority}set priority(e){this._priority!=e&&(this._priority=e,this._onPriorityChange(e))}get(){let e=(0,At.getAnimated)(this);return e&&e.getValue()}to(...e){return X.Globals.to(this,e)}interpolate(...e){return(0,X.deprecateInterpolate)(),X.Globals.to(this,e)}toJSON(){return this.get()}observerAdded(e){e==1&&this._attach()}observerRemoved(e){e==0&&this._detach()}_attach(){}_detach(){}_onChange(e,n=!1){(0,X.callFluidObservers)(this,{type:"change",parent:this,value:e,idle:n})}_onPriorityChange(e){this.idle||X.frameLoop.sort(this),(0,X.callFluidObservers)(this,{type:"priority",parent:this,priority:e})}};var xe=Symbol.for("SpringPhase"),Rt=1,pt=2,lt=4,$e=t=>(t[xe]&Rt)>0,ne=t=>(t[xe]&pt)>0,Ie=t=>(t[xe]&lt)>0,ct=(t,e)=>e?t[xe]|=pt|Rt:t[xe]&=~pt,ft=(t,e)=>e?t[xe]|=lt:t[xe]&=~lt;var ue=class extends te{key;animation=new Ye;queue;defaultProps={};_state={paused:!1,delayed:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set};_pendingCalls=new Set;_lastCallId=0;_lastToId=0;_memoizedDuration=0;constructor(e,n){if(super(),!i.is.und(e)||!i.is.und(n)){let r=i.is.obj(e)?{...e}:{...n,from:e};i.is.und(r.default)&&(r.default=!0),this.start(r)}}get idle(){return!(ne(this)||this._state.asyncTo)||Ie(this)}get goal(){return(0,i.getFluidValue)(this.animation.to)}get velocity(){let e=(0,_.getAnimated)(this);return e instanceof _.AnimatedValue?e.lastVelocity||0:e.getPayload().map(n=>n.lastVelocity||0)}get hasAnimated(){return $e(this)}get isAnimating(){return ne(this)}get isPaused(){return Ie(this)}get isDelayed(){return this._state.delayed}advance(e){let n=!0,r=!1,o=this.animation,{config:s,toValues:u}=o,a=(0,_.getPayload)(o.to);!a&&(0,i.hasFluidValue)(o.to)&&(u=(0,i.toArray)((0,i.getFluidValue)(o.to))),o.values.forEach((d,m)=>{if(d.done)return;let h=d.constructor==_.AnimatedString?1:a?a[m].lastPosition:u[m],v=o.immediate,f=h;if(!v){if(f=d.lastPosition,s.tension<=0){d.done=!0;return}let T=d.elapsedTime+=e,c=o.fromValues[m],g=d.v0!=null?d.v0:d.v0=i.is.arr(s.velocity)?s.velocity[m]:s.velocity,y,A=s.precision||(c==h?.005:Math.min(1,Math.abs(h-c)*.001));if(i.is.und(s.duration))if(s.decay){let P=s.decay===!0?.998:s.decay,I=Math.exp(-(1-P)*T);f=c+g/(1-P)*(1-I),v=Math.abs(d.lastPosition-f)<=A,y=g*I}else{y=d.lastVelocity==null?g:d.lastVelocity;let P=s.restVelocity||A/10,I=s.clamp?0:s.bounce,E=!i.is.und(I),w=c==h?d.v0>0:c<h,O,B=!1,F=1,de=Math.ceil(e/F);for(let K=0;K<de&&(O=Math.abs(y)>P,!(!O&&(v=Math.abs(h-f)<=A,v)));++K){E&&(B=f==h||f>h==w,B&&(y=-y*I,f=h));let W=-s.tension*1e-6*(f-h),S=-s.friction*.001*y,b=(W+S)/s.mass;y=y+b*F,f=f+y*F}}else{let P=1;s.duration>0&&(this._memoizedDuration!==s.duration&&(this._memoizedDuration=s.duration,d.durationProgress>0&&(d.elapsedTime=s.duration*d.durationProgress,T=d.elapsedTime+=e)),P=(s.progress||0)+T/this._memoizedDuration,P=P>1?1:P<0?0:P,d.durationProgress=P),f=c+s.easing(P)*(h-c),y=(f-d.lastPosition)/e,v=P==1}d.lastVelocity=y,Number.isNaN(f)&&(console.warn("Got NaN while animating:",this),v=!0)}a&&!a[m].done&&(v=!1),v?d.done=!0:n=!1,d.setValue(f,s.round)&&(r=!0)});let p=(0,_.getAnimated)(this),l=p.getValue();if(n){let d=(0,i.getFluidValue)(o.to);(l!==d||r)&&!s.decay?(p.setValue(d),this._onChange(d)):r&&s.decay&&this._onChange(l),this._stop()}else r&&this._onChange(l)}set(e){return i.raf.batchedUpdates(()=>{this._stop(),this._focus(e),this._set(e)}),this}pause(){this._update({pause:!0})}resume(){this._update({pause:!1})}finish(){if(ne(this)){let{to:e,config:n}=this.animation;i.raf.batchedUpdates(()=>{this._onStart(),n.decay||this._set(e,!1),this._stop()})}return this}update(e){return(this.queue||(this.queue=[])).push(e),this}start(e,n){let r;return i.is.und(e)?(r=this.queue||[],this.queue=[]):r=[i.is.obj(e)?e:{...n,to:e}],Promise.all(r.map(o=>this._update(o))).then(o=>Ue(this,o))}stop(e){let{to:n}=this.animation;return this._focus(this.get()),Te(this._state,e&&this._lastCallId),i.raf.batchedUpdates(()=>this._stop(n,e)),this}reset(){this._update({reset:!0})}eventObserved(e){e.type=="change"?this._start():e.type=="priority"&&(this.priority=e.priority+1)}_prepareNode(e){let n=this.key||"",{to:r,from:o}=e;r=i.is.obj(r)?r[n]:r,(r==null||Ke(r))&&(r=void 0),o=i.is.obj(o)?o[n]:o,o==null&&(o=void 0);let s={to:r,from:o};return $e(this)||(e.reverse&&([r,o]=[o,r]),o=(0,i.getFluidValue)(o),i.is.und(o)?(0,_.getAnimated)(this)||this._set(r):this._set(o)),s}_update({...e},n){let{key:r,defaultProps:o}=this;e.default&&Object.assign(o,ye(e,(a,p)=>/^on/.test(p)?st(a,r):a)),Ct(this,e,"onProps"),Le(this,"onProps",e,this);let s=this._prepareNode(e);if(Object.isFrozen(this))throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");let u=this._state;return He(++this._lastCallId,{key:r,props:e,defaultProps:o,state:u,actions:{pause:()=>{Ie(this)||(ft(this,!0),(0,i.flushCalls)(u.pauseQueue),Le(this,"onPause",G(this,we(this,this.animation.to)),this))},resume:()=>{Ie(this)&&(ft(this,!1),ne(this)&&this._resume(),(0,i.flushCalls)(u.resumeQueue),Le(this,"onResume",G(this,we(this,this.animation.to)),this))},start:this._merge.bind(this,s)}}).then(a=>{if(e.loop&&a.finished&&!(n&&a.noop)){let p=dt(e);if(p)return this._update(p,!0)}return a})}_merge(e,n,r){if(n.cancel)return this.stop(!0),r(ee(this));let o=!i.is.und(e.to),s=!i.is.und(e.from);if(o||s)if(n.callId>this._lastToId)this._lastToId=n.callId;else return r(ee(this));let{key:u,defaultProps:a,animation:p}=this,{to:l,from:d}=p,{to:m=l,from:h=d}=e;s&&!o&&(!n.default||i.is.und(m))&&(m=h),n.reverse&&([m,h]=[h,m]);let v=!(0,i.isEqual)(h,d);v&&(p.from=h),h=(0,i.getFluidValue)(h);let f=!(0,i.isEqual)(m,l);f&&this._focus(m);let T=Ke(n.to),{config:c}=p,{decay:g,velocity:y}=c;(o||s)&&(c.velocity=0),n.config&&!T&&xt(c,k(n.config,u),n.config!==a.config?k(a.config,u):void 0);let A=(0,_.getAnimated)(this);if(!A||i.is.und(m))return r(G(this,!0));let P=i.is.und(n.reset)?s&&!n.default:!i.is.und(h)&&ge(n.reset,u),I=P?h:this.get(),E=Re(m),w=i.is.num(E)||i.is.arr(E)||(0,i.isAnimatedString)(E),O=!T&&(!w||ge(a.immediate||n.immediate,u));if(f){let K=(0,_.getAnimatedType)(m);if(K!==A.constructor)if(O)A=this._set(E);else throw Error(`Cannot animate between ${A.constructor.name} and ${K.name}, as the "to" prop suggests`)}let B=A.constructor,F=(0,i.hasFluidValue)(m),de=!1;if(!F){let K=P||!$e(this)&&v;(f||K)&&(de=(0,i.isEqual)(Re(I),E),F=!de),(!(0,i.isEqual)(p.immediate,O)&&!O||!(0,i.isEqual)(c.decay,g)||!(0,i.isEqual)(c.velocity,y))&&(F=!0)}if(de&&ne(this)&&(p.changed&&!P?F=!0:F||this._stop(l)),!T&&((F||(0,i.hasFluidValue)(l))&&(p.values=A.getPayload(),p.toValues=(0,i.hasFluidValue)(m)?null:B==_.AnimatedString?[1]:(0,i.toArray)(E)),p.immediate!=O&&(p.immediate=O,!O&&!P&&this._set(l)),F)){let{onRest:K}=p;(0,i.each)(en,S=>Ct(this,n,S));let W=G(this,we(this,l));(0,i.flushCalls)(this._pendingCalls,W),this._pendingCalls.add(r),p.changed&&i.raf.batchedUpdates(()=>{p.changed=!P,K?.(W,this),P?k(a.onRest,W):p.onStart?.(W,this)})}P&&this._set(I),T?r(We(n.to,n,this._state,this)):F?this._start():ne(this)&&!f?this._pendingCalls.add(r):r(ut(I))}_focus(e){let n=this.animation;e!==n.to&&((0,i.getFluidObservers)(this)&&this._detach(),n.to=e,(0,i.getFluidObservers)(this)&&this._attach())}_attach(){let e=0,{to:n}=this.animation;(0,i.hasFluidValue)(n)&&((0,i.addFluidObserver)(n,this),Ee(n)&&(e=n.priority+1)),this.priority=e}_detach(){let{to:e}=this.animation;(0,i.hasFluidValue)(e)&&(0,i.removeFluidObserver)(e,this)}_set(e,n=!0){let r=(0,i.getFluidValue)(e);if(!i.is.und(r)){let o=(0,_.getAnimated)(this);if(!o||!(0,i.isEqual)(r,o.getValue())){let s=(0,_.getAnimatedType)(r);!o||o.constructor!=s?(0,_.setAnimated)(this,s.create(r)):o.setValue(r),o&&i.raf.batchedUpdates(()=>{this._onChange(r,n)})}}return(0,_.getAnimated)(this)}_onStart(){let e=this.animation;e.changed||(e.changed=!0,Le(this,"onStart",G(this,we(this,e.to)),this))}_onChange(e,n){n||(this._onStart(),k(this.animation.onChange,e,this)),k(this.defaultProps.onChange,e,this),super._onChange(e,n)}_start(){let e=this.animation;(0,_.getAnimated)(this).reset((0,i.getFluidValue)(e.to)),e.immediate||(e.fromValues=e.values.map(n=>n.lastPosition)),ne(this)||(ct(this,!0),Ie(this)||this._resume())}_resume(){i.Globals.skipAnimation?this.finish():i.frameLoop.start(this)}_stop(e,n){if(ne(this)){ct(this,!1);let r=this.animation;(0,i.each)(r.values,s=>{s.done=!0}),r.toValues&&(r.onChange=r.onPause=r.onResume=void 0),(0,i.callFluidObservers)(this,{type:"idle",parent:this});let o=n?ee(this.get()):G(this.get(),we(this,e??r.to));(0,i.flushCalls)(this._pendingCalls,o),r.changed&&(r.changed=!1,Le(this,"onRest",o,this))}}};function we(t,e){let n=Re(e),r=Re(t.get());return(0,i.isEqual)(r,n)}function dt(t,e=t.loop,n=t.to){let r=k(e);if(r){let o=r!==!0&&Se(r),s=(o||t).reverse,u=!o||o.reset;return Ve({...t,loop:e,default:!1,pause:void 0,to:!s||Ke(n)?n:void 0,from:u?t.from:void 0,reset:u,...o})}}function Ve(t){let{to:e,from:n}=t=Se(t),r=new Set;return i.is.obj(e)&&vt(e,r),i.is.obj(n)&&vt(n,r),t.keys=r.size?Array.from(r):null,t}function It(t){let e=Ve(t);return i.is.und(e.default)&&(e.default=ye(e)),e}function vt(t,e){(0,i.eachProp)(t,(n,r)=>n!=null&&e.add(r))}var en=["onStart","onRest","onChange","onPause","onResume"];function Ct(t,e,n){t.animation[n]=e[n]!==Ge(e,n)?st(e[n],t.key):void 0}function Le(t,e,...n){t.animation[e]?.(...n),t.defaultProps[e]?.(...n)}var x=require("@react-spring/shared");var tn=["onStart","onChange","onRest"],nn=1,pe=class{id=nn++;springs={};queue=[];ref;_flush;_initialProps;_lastAsyncId=0;_active=new Set;_changed=new Set;_started=!1;_item;_state={paused:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set};_events={onStart:new Map,onChange:new Map,onRest:new Map};constructor(e,n){this._onFrame=this._onFrame.bind(this),n&&(this._flush=n),e&&this.start({default:!0,...e})}get idle(){return!this._state.asyncTo&&Object.values(this.springs).every(e=>e.idle&&!e.isDelayed&&!e.isPaused)}get item(){return this._item}set item(e){this._item=e}get(){let e={};return this.each((n,r)=>e[r]=n.get()),e}set(e){for(let n in e){let r=e[n];x.is.und(r)||this.springs[n].set(r)}}update(e){return e&&this.queue.push(Ve(e)),this}start(e){let{queue:n}=this;return e?n=(0,x.toArray)(e).map(Ve):this.queue=[],this._flush?this._flush(this,n):(Ft(this,n),Ze(this,n))}stop(e,n){if(e!==!!e&&(n=e),n){let r=this.springs;(0,x.each)((0,x.toArray)(n),o=>r[o].stop(!!e))}else Te(this._state,this._lastAsyncId),this.each(r=>r.stop(!!e));return this}pause(e){if(x.is.und(e))this.start({pause:!0});else{let n=this.springs;(0,x.each)((0,x.toArray)(e),r=>n[r].pause())}return this}resume(e){if(x.is.und(e))this.start({pause:!1});else{let n=this.springs;(0,x.each)((0,x.toArray)(e),r=>n[r].resume())}return this}each(e){(0,x.eachProp)(this.springs,e)}_onFrame(){let{onStart:e,onChange:n,onRest:r}=this._events,o=this._active.size>0,s=this._changed.size>0;(o&&!this._started||s&&!this._started)&&(this._started=!0,(0,x.flush)(e,([p,l])=>{l.value=this.get(),p(l,this,this._item)}));let u=!o&&this._started,a=s||u&&r.size?this.get():null;s&&n.size&&(0,x.flush)(n,([p,l])=>{l.value=a,p(l,this,this._item)}),u&&(this._started=!1,(0,x.flush)(r,([p,l])=>{l.value=a,p(l,this,this._item)}))}eventObserved(e){if(e.type=="change")this._changed.add(e.parent),e.idle||this._active.add(e.parent);else if(e.type=="idle")this._active.delete(e.parent);else return;x.raf.onFrame(this._onFrame)}};function Ze(t,e){return Promise.all(e.map(n=>Vt(t,n))).then(n=>Ue(t,n))}async function Vt(t,e,n){let{keys:r,to:o,from:s,loop:u,onRest:a,onResolve:p}=e,l=x.is.obj(e.default)&&e.default;u&&(e.loop=!1),o===!1&&(e.to=null),s===!1&&(e.from=null);let d=x.is.arr(o)||x.is.fun(o)?o:void 0;d?(e.to=void 0,e.onRest=void 0,l&&(l.onRest=void 0)):(0,x.each)(tn,T=>{let c=e[T];if(x.is.fun(c)){let g=t._events[T];e[T]=({finished:y,cancelled:A})=>{let P=g.get(c);P?(y||(P.finished=!1),A&&(P.cancelled=!0)):g.set(c,{value:null,finished:y||!1,cancelled:A||!1})},l&&(l[T]=e[T])}});let m=t._state;e.pause===!m.paused?(m.paused=e.pause,(0,x.flushCalls)(e.pause?m.pauseQueue:m.resumeQueue)):m.paused&&(e.pause=!0);let h=(r||Object.keys(t.springs)).map(T=>t.springs[T].start(e)),v=e.cancel===!0||Ge(e,"cancel")===!0;(d||v&&m.asyncId)&&h.push(He(++t._lastAsyncId,{props:e,state:m,actions:{pause:x.noop,resume:x.noop,start(T,c){v?(Te(m,t._lastAsyncId),c(ee(t))):(T.onRest=a,c(We(d,T,m,t)))}}})),m.paused&&await new Promise(T=>{m.resumeQueue.add(T)});let f=Ue(t,await Promise.all(h));if(u&&f.finished&&!(n&&f.noop)){let T=dt(e,u,o);if(T)return Ft(t,[T]),Vt(t,T,!0)}return p&&x.raf.batchedUpdates(()=>p(f,t,t.item)),f}function Me(t,e){let n={...t.springs};return e&&(0,x.each)((0,x.toArray)(e),r=>{x.is.und(r.keys)&&(r=Ve(r)),x.is.obj(r.to)||(r={...r,to:void 0}),Ot(n,r,o=>_t(o))}),mt(t,n),n}function mt(t,e){(0,x.eachProp)(e,(n,r)=>{t.springs[r]||(t.springs[r]=n,(0,x.addFluidObserver)(n,t))})}function _t(t,e){let n=new ue;return n.key=t,e&&(0,x.addFluidObserver)(n,e),n}function Ot(t,e,n){e.keys&&(0,x.each)(e.keys,r=>{(t[r]||(t[r]=n(r)))._prepareNode(e)})}function Ft(t,e){(0,x.each)(e,n=>{Ot(t.springs,n,r=>_t(r,t))})}var tt=Pt(require("react")),kt=require("react"),Ut=require("@react-spring/shared"),re=({children:t,...e})=>{let n=(0,kt.useContext)(et),r=e.pause||!!n.pause,o=e.immediate||!!n.immediate;e=(0,Ut.useMemoOne)(()=>({pause:r,immediate:o}),[r,o]);let{Provider:s}=et;return tt.createElement(s,{value:e},t)},et=rn(re,{});re.Provider=et.Provider;re.Consumer=et.Consumer;function rn(t,e){return Object.assign(t,tt.createContext(e)),t.Provider._context=t,t.Consumer._context=t,t}var q=require("@react-spring/shared"),le=()=>{let t=[],e=function(r){(0,q.deprecateDirectCall)();let o=[];return(0,q.each)(t,(s,u)=>{if(q.is.und(r))o.push(s.start());else{let a=n(r,s,u);a&&o.push(s.start(a))}}),o};e.current=t,e.add=function(r){t.includes(r)||t.push(r)},e.delete=function(r){let o=t.indexOf(r);~o&&t.splice(o,1)},e.pause=function(){return(0,q.each)(t,r=>r.pause(...arguments)),this},e.resume=function(){return(0,q.each)(t,r=>r.resume(...arguments)),this},e.set=function(r){(0,q.each)(t,(o,s)=>{let u=q.is.fun(r)?r(s,o):r;u&&o.set(u)})},e.start=function(r){let o=[];return(0,q.each)(t,(s,u)=>{if(q.is.und(r))o.push(s.start());else{let a=this._getProps(r,s,u);a&&o.push(s.start(a))}}),o},e.stop=function(){return(0,q.each)(t,r=>r.stop(...arguments)),this},e.update=function(r){return(0,q.each)(t,(o,s)=>o.update(this._getProps(r,o,s))),this};let n=function(r,o,s){return q.is.fun(r)?r(s,o):r};return e._getProps=n,e};function je(t,e,n){let r=j.is.fun(e)&&e;r&&!n&&(n=[]);let o=(0,J.useMemo)(()=>r||arguments.length==3?le():void 0,[]),s=(0,J.useRef)(0),u=(0,j.useForceUpdate)(),a=(0,J.useMemo)(()=>({ctrls:[],queue:[],flush(g,y){let A=Me(g,y);return s.current>0&&!a.queue.length&&!Object.keys(A).some(I=>!g.springs[I])?Ze(g,y):new Promise(I=>{mt(g,A),a.queue.push(()=>{I(Ze(g,y))}),u()})}}),[]),p=(0,J.useRef)([...a.ctrls]),l=[],d=(0,j.usePrev)(t)||0;(0,J.useMemo)(()=>{(0,j.each)(p.current.slice(t,d),g=>{ke(g,o),g.stop(!0)}),p.current.length=t,m(d,t)},[t]),(0,J.useMemo)(()=>{m(0,Math.min(d,t))},n);function m(g,y){for(let A=g;A<y;A++){let P=p.current[A]||(p.current[A]=new pe(null,a.flush)),I=r?r(A,P):e[A];I&&(l[A]=It(I))}}let h=p.current.map((g,y)=>Me(g,l[y])),v=(0,J.useContext)(re),f=(0,j.usePrev)(v),T=v!==f&&Be(v);(0,j.useIsomorphicLayoutEffect)(()=>{s.current++,a.ctrls=p.current;let{queue:g}=a;g.length&&(a.queue=[],(0,j.each)(g,y=>y())),(0,j.each)(p.current,(y,A)=>{o?.add(y),T&&y.start({default:v});let P=l[A];P&&(ve(y,P.ref),y.ref?y.queue.push(P):y.start(P))})}),(0,j.useOnce)(()=>()=>{(0,j.each)(a.ctrls,g=>g.stop(!0))});let c=h.map(g=>({...g}));return o?[c,o]:c}function oe(t,e){let n=Et.is.fun(t),[[r],o]=je(1,n?t:[t],n?e||[]:e);return n||arguments.length==2?[r,o]:r}var wt=require("react");var on=()=>le(),sn=()=>(0,wt.useState)(on)[0];var nt=require("@react-spring/shared");var an=(t,e)=>{let n=(0,nt.useConstant)(()=>new ue(t,e));return(0,nt.useOnce)(()=>()=>{n.stop()}),n};var be=require("@react-spring/shared");function ht(t,e,n){let r=be.is.fun(e)&&e;r&&!n&&(n=[]);let o=!0,s,u=je(t,(a,p)=>{let l=r?r(a,p):e;return s=l.ref,o=o&&l.reverse,l},n||[{}]);if((0,be.useIsomorphicLayoutEffect)(()=>{(0,be.each)(u[1].current,(a,p)=>{let l=u[1].current[p+(o?1:-1)];if(ve(a,s),a.ref){l&&a.update({to:l.springs});return}l?a.start({to:l.springs}):a.start()})},n),r||arguments.length==3){let a=s??u[1];return a._getProps=(p,l,d)=>{let m=be.is.fun(p)?p(d,l):p;if(m){let h=a.current[d+(m.reverse?1:-1)];return h&&(m.to=h.springs),m}},u}return u[0]}var Ne=Pt(require("react")),ce=require("react"),R=require("@react-spring/shared");function gt(t,e,n){let r=R.is.fun(e)&&e,{reset:o,sort:s,trail:u=0,expires:a=!0,exitBeforeEnter:p=!1,onDestroyed:l,ref:d,config:m}=r?r():e,h=(0,ce.useMemo)(()=>r||arguments.length==3?le():void 0,[]),v=(0,R.toArray)(t),f=[],T=(0,ce.useRef)(null),c=o?null:T.current;(0,R.useIsomorphicLayoutEffect)(()=>{T.current=f}),(0,R.useOnce)(()=>((0,R.each)(f,S=>{h?.add(S.ctrl),S.ctrl.ref=h}),()=>{(0,R.each)(T.current,S=>{S.expired&&clearTimeout(S.expirationId),ke(S.ctrl,h),S.ctrl.stop(!0)})}));let g=pn(v,r?r():e,c),y=o&&T.current||[];(0,R.useIsomorphicLayoutEffect)(()=>(0,R.each)(y,({ctrl:S,item:b,key:N})=>{ke(S,h),k(l,b,N)}));let A=[];if(c&&(0,R.each)(c,(S,b)=>{S.expired?(clearTimeout(S.expirationId),y.push(S)):(b=A[b]=g.indexOf(S.key),~b&&(f[b]=S))}),(0,R.each)(v,(S,b)=>{f[b]||(f[b]={key:g[b],item:S,phase:"mount",ctrl:new pe},f[b].ctrl.item=S)}),A.length){let S=-1,{leave:b}=r?r():e;(0,R.each)(A,(N,D)=>{let M=c[D];~N?(S=f.indexOf(M),f[S]={...M,item:v[N]}):b&&f.splice(++S,0,M)})}R.is.fun(s)&&f.sort((S,b)=>s(S.item,b.item));let P=-u,I=(0,R.useForceUpdate)(),E=ye(e),w=new Map,O=(0,ce.useRef)(new Map),B=(0,ce.useRef)(!1);(0,R.each)(f,(S,b)=>{let N=S.key,D=S.phase,M=r?r():e,z,$,Nt=k(M.delay||0,N);if(D=="mount")z=M.enter,$="enter";else{let Y=g.indexOf(N)<0;if(D!="leave")if(Y)z=M.leave,$="leave";else if(z=M.update)$="update";else return;else if(!Y)z=M.enter,$="enter";else return}if(z=k(z,S.item,b),z=R.is.obj(z)?Se(z):{to:z},!z.config){let Y=m||E.config;z.config=k(Y,S.item,b,$)}P+=u;let me={...E,delay:Nt+P,ref:d,immediate:M.immediate,reset:!1,...z};if($=="enter"&&R.is.und(me.from)){let Y=r?r():e,Fe=R.is.und(Y.initial)||c?Y.from:Y.initial;me.from=k(Fe,S.item,b)}let{onResolve:Dt}=me;me.onResolve=Y=>{k(Dt,Y);let Fe=T.current,ae=Fe.find(qe=>qe.key===N);if(!!ae&&!(Y.cancelled&&ae.phase!="update")&&ae.ctrl.idle){let qe=Fe.every(he=>he.ctrl.idle);if(ae.phase=="leave"){let he=k(a,ae.item);if(he!==!1){let ot=he===!0?0:he;if(ae.expired=!0,!qe&&ot>0){ot<=2147483647&&(ae.expirationId=setTimeout(I,ot));return}}}qe&&Fe.some(he=>he.expired)&&(O.current.delete(ae),p&&(B.current=!0),I())}};let St=Me(S.ctrl,me);$==="leave"&&p?O.current.set(S,{phase:$,springs:St,payload:me}):w.set(S,{phase:$,springs:St,payload:me})});let F=(0,ce.useContext)(re),de=(0,R.usePrev)(F),K=F!==de&&Be(F);(0,R.useIsomorphicLayoutEffect)(()=>{K&&(0,R.each)(f,S=>{S.ctrl.start({default:F})})},[F]),(0,R.each)(w,(S,b)=>{if(O.current.size){let N=f.findIndex(D=>D.key===b.key);f.splice(N,1)}}),(0,R.useIsomorphicLayoutEffect)(()=>{(0,R.each)(O.current.size?O.current:w,({phase:S,payload:b},N)=>{let{ctrl:D}=N;N.phase=S,h?.add(D),K&&S=="enter"&&D.start({default:F}),b&&(ve(D,b.ref),(D.ref||h)&&!B.current?D.update(b):(D.start(b),B.current&&(B.current=!1)))})},o?void 0:n);let W=S=>Ne.createElement(Ne.Fragment,null,f.map((b,N)=>{let{springs:D}=w.get(b)||b.ctrl,M=S({...D},b.item,b,N);return M&&M.type?Ne.createElement(M.type,{...M.props,key:R.is.str(b.key)||R.is.num(b.key)?b.key:b.ctrl.id,ref:M.ref}):M}));return h?[W,h]:W}var un=1;function pn(t,{key:e,keys:n=e},r){if(n===null){let o=new Set;return t.map(s=>{let u=r&&r.find(a=>a.item===s&&a.phase!=="leave"&&!o.has(a));return u?(o.add(u),u.key):un++})}return R.is.und(n)?t:R.is.fun(n)?t.map(n):(0,R.toArray)(n)}var _e=require("@react-spring/shared");var ln=({container:t,...e}={})=>{let[n,r]=oe(()=>({scrollX:0,scrollY:0,scrollXProgress:0,scrollYProgress:0,...e}),[]);return(0,_e.useIsomorphicLayoutEffect)(()=>{let o=(0,_e.onScroll)(({x:s,y:u})=>{r.start({scrollX:s.current,scrollXProgress:s.progress,scrollY:u.current,scrollYProgress:u.progress})},{container:t?.current||void 0});return()=>{(0,_e.each)(Object.values(n),s=>s.stop()),o()}},[]),n};var Oe=require("@react-spring/shared");var cn=({container:t,...e})=>{let[n,r]=oe(()=>({width:0,height:0,...e}),[]);return(0,Oe.useIsomorphicLayoutEffect)(()=>{let o=(0,Oe.onResize)(({width:s,height:u})=>{r.start({width:s,height:u,immediate:n.width.get()===0||n.height.get()===0})},{container:t?.current||void 0});return()=>{(0,Oe.each)(Object.values(n),s=>s.stop()),o()}},[]),n};var rt=require("react"),De=require("@react-spring/shared");var fn={any:0,all:1};function dn(t,e){let[n,r]=(0,rt.useState)(!1),o=(0,rt.useRef)(),s=De.is.fun(t)&&t,u=s?s():{},{to:a={},from:p={},...l}=u,d=s?e:t,[m,h]=oe(()=>({from:p,...l}),[]);return(0,De.useIsomorphicLayoutEffect)(()=>{let v=o.current,{root:f,once:T,amount:c="any",...g}=d??{};if(!v||T&&n||typeof IntersectionObserver>"u")return;let y=new WeakMap,A=()=>(a&&h.start(a),r(!0),T?void 0:()=>{p&&h.start(p),r(!1)}),P=E=>{E.forEach(w=>{let O=y.get(w.target);if(w.isIntersecting!==Boolean(O))if(w.isIntersecting){let B=A();De.is.fun(B)?y.set(w.target,B):I.unobserve(w.target)}else O&&(O(),y.delete(w.target))})},I=new IntersectionObserver(P,{root:f&&f.current||void 0,threshold:typeof c=="number"||Array.isArray(c)?c:fn[c],...g});return I.observe(v),()=>I.unobserve(v)},[d]),s?[o,m]:[o,n]}function mn({children:t,...e}){return t(oe(e))}var Lt=require("@react-spring/shared");function hn({items:t,children:e,...n}){let r=ht(t.length,n);return t.map((o,s)=>{let u=e(o,s);return Lt.is.fun(u)?u(r[s]):u})}function gn({items:t,children:e,...n}){return gt(t,n)(e)}var jt=require("@react-spring/shared");var C=require("@react-spring/shared");var ie=require("@react-spring/animated"),se=class extends te{constructor(n,r){super();this.source=n;this.calc=(0,C.createInterpolator)(...r);let o=this._get(),s=(0,ie.getAnimatedType)(o);(0,ie.setAnimated)(this,s.create(o))}key;idle=!0;calc;_active=new Set;advance(n){let r=this._get(),o=this.get();(0,C.isEqual)(r,o)||((0,ie.getAnimated)(this).setValue(r),this._onChange(r,this.idle)),!this.idle&&Mt(this._active)&&yt(this)}_get(){let n=C.is.arr(this.source)?this.source.map(C.getFluidValue):(0,C.toArray)((0,C.getFluidValue)(this.source));return this.calc(...n)}_start(){this.idle&&!Mt(this._active)&&(this.idle=!1,(0,C.each)((0,ie.getPayload)(this),n=>{n.done=!1}),C.Globals.skipAnimation?(C.raf.batchedUpdates(()=>this.advance()),yt(this)):C.frameLoop.start(this))}_attach(){let n=1;(0,C.each)((0,C.toArray)(this.source),r=>{(0,C.hasFluidValue)(r)&&(0,C.addFluidObserver)(r,this),Ee(r)&&(r.idle||this._active.add(r),n=Math.max(n,r.priority+1))}),this.priority=n,this._start()}_detach(){(0,C.each)((0,C.toArray)(this.source),n=>{(0,C.hasFluidValue)(n)&&(0,C.removeFluidObserver)(n,this)}),this._active.clear(),yt(this)}eventObserved(n){n.type=="change"?n.idle?this.advance():(this._active.add(n.parent),this._start()):n.type=="idle"?this._active.delete(n.parent):n.type=="priority"&&(this.priority=(0,C.toArray)(this.source).reduce((r,o)=>Math.max(r,(Ee(o)?o.priority:0)+1),0))}};function yn(t){return t.idle!==!1}function Mt(t){return!t.size||Array.from(t).every(yn)}function yt(t){t.idle||(t.idle=!0,(0,C.each)((0,ie.getPayload)(t),e=>{e.done=!0}),(0,C.callFluidObservers)(t,{type:"idle",parent:t}))}var Sn=(t,...e)=>new se(t,e),Pn=(t,...e)=>((0,jt.deprecateInterpolate)(),new se(t,e));var Ae=require("@react-spring/shared");Ae.Globals.assign({createStringInterpolator:Ae.createStringInterpolator,to:(t,e)=>new se(t,e)});var Tn=Ae.frameLoop.advance;var fe=require("@react-spring/shared");L(U,require("@react-spring/types"),module.exports);0&&(module.exports={BailSignal,Controller,FrameValue,Globals,Interpolation,Spring,SpringContext,SpringRef,SpringValue,Trail,Transition,config,createInterpolator,easings,inferTo,interpolate,to,update,useChain,useInView,useIsomorphicLayoutEffect,useReducedMotion,useResize,useScroll,useSpring,useSpringRef,useSpringValue,useSprings,useTrail,useTransition});
