"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("three"),r=require("../BufferGeometryUtils-903f7ecb.js");require("../types/helpers.cjs.js");exports.LDrawUtils=class{static mergeObject(e){function i(r,e,i,n){const a=new t.BufferGeometry,o=r.getAttribute("position").array,s=3===i?r.getAttribute("normal").array:null,u=Math.min(e.count,Math.floor(o.length/3)-e.start),l=3*e.start,c=3*(e.start+u),f=o.subarray(l,c),m=null!==s?s.subarray(l,c):null;if(a.setAttribute("position",new t.BufferAttribute(f,3)),null!==m&&a.setAttribute("normal",new t.BufferAttribute(m,3)),n){const e=r.getAttribute("control0").array.subarray(l,c),i=r.getAttribute("control1").array.subarray(l,c),n=r.getAttribute("direction").array.subarray(l,c);a.setAttribute("control0",new t.BufferAttribute(e,3,!1)),a.setAttribute("control1",new t.BufferAttribute(i,3,!1)),a.setAttribute("direction",new t.BufferAttribute(n,3,!1))}return a}function n(t,r,e){const i=e[t.uuid];i?i.arr.push(r):e[t.uuid]={mat:t,arr:[r]}}function a(t,r){if(!t)return;const e=t.array,i=Math.floor(e.length/3);let n=0;for(let t=0;t<i;t++){const t=e[n],i=e[n+1],a=e[n+2];e[n]=e[n+3],e[n+1]=e[n+4],e[n+2]=e[n+5],e[n+3]=t,e[n+4]=i,e[n+5]=a,n+=3*r}}const o={},s={},u={};e.updateMatrixWorld(!0);const l=new t.Matrix3;e.traverse((t=>{if(t.isMesh|t.isLineSegments){const r=t.isMesh?3:2,e=t.geometry.clone();t.matrixWorld.determinant()<0&&(a(e.attributes.position,r),a(e.attributes.normal,r)),e.applyMatrix4(t.matrixWorld),t.isConditionalLine&&(e.attributes.control0.applyMatrix4(t.matrixWorld),e.attributes.control1.applyMatrix4(t.matrixWorld),l.getNormalMatrix(t.matrixWorld),e.attributes.direction.applyNormalMatrix(l));const c=t.isMesh?o:t.isConditionalLine?u:s;if(Array.isArray(t.material))for(const a in e.groups){const o=e.groups[a];n(t.material[o.materialIndex],i(e,o,r,t.isConditionalLine),c)}else n(t.material,e,c)}}));const c=new t.Group,f=Object.keys(o);for(const e in f){const i=o[f[e]],n=r.mergeBufferGeometries(i.arr);c.add(new t.Mesh(n,i.mat))}const m=Object.keys(s);for(const e in m){const i=s[m[e]],n=r.mergeBufferGeometries(i.arr);c.add(new t.LineSegments(n,i.mat))}const b=Object.keys(u);for(const e in b){const i=u[b[e]],n=r.mergeBufferGeometries(i.arr),a=new t.LineSegments(n,i.mat);a.isConditionalLine=!0,c.add(a)}return c.userData.constructionStep=0,c.userData.numConstructionSteps=1,c}};
